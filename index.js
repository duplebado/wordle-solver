const words = require('an-array-of-english-words');
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const WORD_LENGTH = 5;

const INCORRECT_WORD_CLG = `\n====================================================================================================
\nValid word should be small letters and contain ${WORD_LENGTH} letters only. Please pick another word
\n====================================================================================================
`;

const INCORRECT_COLOR_REP_CLG = `====================================================================================================
\n colorRepresentation should be exactly 5 characters (each a digit between 0 and 2) long                     
\n The digits 0 - 2 denotes color of each letter of the word
\n 0 means grey
\n 1 means yellow
\n 2 means green
\n Examples are: 01222, 00000, 01112, 22210, e.t.c
\n====================================================================================================`

const wordClue = {
    include: "",
    excludePosition: {
        1: "",
        2: "",
        3: "",
        4: "",
        5: ""
    },
    correctPosition: {
        1: null,
        2: null,
        3: null,
        4: null,
        5: null
    }
}

const generatetWord = (currentWord = null) => {
    let word = possibleWords[Math.floor(Math.random() * possibleWords.length)];

    if (currentWord === word && possibleWords.length !== 1) {
        return generatetWord (currentWord);
    }
    return word;
}

const askIfFirstWordBeAutogenerated = () => {
    return new Promise((resolve, reject) => {
      rl.question("Do you want me to give you a word to start with ?  ", (answer) => {
        resolve(answer)
      });
    });
};


const getUserGeneratedFirstWord = () => {
    return new Promise((resolve, reject) => {
      rl.question("\nWhat word did you decide to start with ?  ", (answer) => {
        resolve(answer)
      });
    });
};

const getColorRepresentation = () => {
    return new Promise((resolve, reject) => {
      rl.question("\nWhat was the colorRepresentation ?  ", (answer) => {
        resolve(answer)
      });
    });
};

const checkColorRepresentationValidity = (colorRep) => {
    if (colorRep.length !== WORD_LENGTH) {
        console.log(INCORRECT_COLOR_REP_CLG)
        return false;
    }

    let pattern = /^[0-2]+$/;
    let result = pattern.test(colorRep);

    if (!result) {
        console.log(INCORRECT_COLOR_REP_CLG)
    }

    return result;
}

const checkWordValidity = (word) => {
    if (word.length !== WORD_LENGTH) {
        console.log(INCORRECT_WORD_CLG);
        return false;
    }

    let pattern = /^[a-z]+$/;
    let result = pattern.test(word);

    if (!result) {
        console.log(INCORRECT_WORD_CLG);
    }

    return result;
}

const addToclue = (word, colorRepresentation) => {
    const mySet1 = new Set();

    for (let i = 0; i < WORD_LENGTH; i++) {
        if (colorRepresentation[i] === "0") {
            if (!mySet1.has(word[i])) {
                mySet1.add(word[i])
                let keyName = String(Number(i) + 1)
                wordClue.excludePosition[keyName] += word[i]
            }
            
        } else if (colorRepresentation[i] === "1") {
            wordClue.include += word[i]
        } else if (colorRepresentation[i] === "2"){
            let keyName = String(Number(i) + 1)
            wordClue.correctPosition[keyName] = word[i]
        }
    }
}

const reEvaluatePossibleWords =(currentWord, colorRepresentation) => {
    let newPossibleWordsArr;

    let correctPositionPattern = "";

    for (let key in wordClue.correctPosition) {
        if (wordClue.correctPosition[key] !== null) {
            if (key === "1") {
                correctPositionPattern += "^" + wordClue.correctPosition[key];
            } else if (key === "5") {
                correctPositionPattern += wordClue.correctPosition[key] + "$"
            } else {
                correctPositionPattern += wordClue.correctPosition[key];
            }
        } else {
            if (key === "1") {
                if (wordClue.excludePosition[key] !== "") {
                    correctPositionPattern += `^[^${wordClue.excludePosition[key]}]`
                } else {
                    correctPositionPattern += "^[a-z]";
                }
            } else if (key === "5") {
                if (wordClue.excludePosition[key] !== "") {
                    correctPositionPattern += `[^${wordClue.excludePosition[key]}]$`
                } else {
                    correctPositionPattern += "[a-z]$";
                }
            } else {
                if (wordClue.excludePosition[key] !== "") {
                    correctPositionPattern += `[^${wordClue.excludePosition[key]}]`
                } else {
                    correctPositionPattern += "[a-z]";
                }
            }
        }
    }

    let mustIncludepattern = ""; 


    if (wordClue.include !== "") {
        for (let i = 0; i < wordClue.include.length; i++) {
            mustIncludepattern += `(?=.*${wordClue.include[i]})` 
        }
    }    

    newPossibleWordsArr = possibleWords.filter(word => {
        let matchForCorrectPosition;
        let matchForMustIncludepattern;

        let re = new RegExp(correctPositionPattern);

       matchForCorrectPosition = re.test(word);

        if (mustIncludepattern) {
            let re = new RegExp(mustIncludepattern);
            matchForMustIncludepattern = re.test(word);

            return matchForCorrectPosition && matchForMustIncludepattern;
        }

        return matchForCorrectPosition;
    });

    return newPossibleWordsArr;
}

const checkIfResultIsCorrect = (colorRepresentation) => {
    let count = 0;
    for (let i = 0; i <= WORD_LENGTH; i++) {
        if (colorRepresentation[i] === "2") {
            count++
        }
    }

    return count === WORD_LENGTH;
}

const generateNextWordAndAskColorRepresentation = () => {
    return new Promise((resolve, reject) => {
        let nextWord = generatetWord()
      console.log("\nOkay Okay, I get it. Don't give me that look. Let's give it another go.\n")
      console.log(`\n Try the word ---> ${nextWord}\n`)
      rl.question("\nWhat was the colorRepresentation this time ?  ", (answer) => {
        resolve([nextWord, answer])
      });
    });
};

let possibleWords = words.filter(d => d.length === WORD_LENGTH);

let currentWord;

console.log("\nWelcome to Wordle solver\n");
console.log("--------------------------------------------------------------------------------\n");
  
const main = async () => {
    let numOfTrys = 1;
    let currentWord;
    let firstWordWasAutogenerated = false;


    let response = await askIfFirstWordBeAutogenerated();

    while (response !== "yes" && response !== "no") {
        console.log("\nValid response is 'yes' or 'no'. Try again please \n")
        response = await askIfFirstWordBeAutogenerated();
    }

    if (response === "yes"){
        currentWord = generatetWord();
        firstWordWasAutogenerated = true;
        console.log("\nStart with this word ----> ", currentWord)
    } else {
        currentWord = await getUserGeneratedFirstWord();

        while (!checkWordValidity(currentWord)) {
            currentWord = await getUserGeneratedFirstWord();
        }
    }

    let colorRepresentation = await getColorRepresentation();

    while (!checkColorRepresentationValidity(colorRepresentation)) {
        colorRepresentation = await getColorRepresentation();
    }

    if (checkIfResultIsCorrect(colorRepresentation)) {
        if (firstWordWasAutogenerated) {
            console.log("\nGreat! I am glad I could be of help.\n");
        }else {
            console.log("\n You did it! Nice work")
        }
    } else {
        // currentWord = generatetWord();
        // numOfTrys++;

        while (!checkIfResultIsCorrect(colorRepresentation) && numOfTrys < 6) {
            addToclue(currentWord, colorRepresentation);
    
            possibleWords = reEvaluatePossibleWords(currentWord, colorRepresentation);

            let [nextWord, nextColorRepresentation] = await generateNextWordAndAskColorRepresentation();

            currentWord = nextWord;
            colorRepresentation = nextColorRepresentation;

            while (!checkColorRepresentationValidity(colorRepresentation)) {
                colorRepresentation = await getColorRepresentation();
            }
            numOfTrys++;
        };


        if (checkIfResultIsCorrect(colorRepresentation)) {
            if (numOfTrys > 4) {
                console.log("\n That was close! Glad we did it eventually\n");
            } else {
                console.log("\nGreat! I am glad I could be of help.\n");
            }
        } else {
            console.log("\n Sorry to have let you down. In my defence, we were very close. Let's do this again tomorrow. \n")
        }
    }   

    rl.close()
}
  
main();